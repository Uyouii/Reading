## å“ˆå¸Œè¡¨

### è®¾è®¡åŸç†

æƒ³è¦å®ç°ä¸€ä¸ªæ€§èƒ½ä¼˜å¼‚çš„å“ˆå¸Œè¡¨ï¼Œéœ€è¦æ³¨æ„ä¸¤ä¸ªå…³é”®ç‚¹ â€”â€” å“ˆå¸Œå‡½æ•°å’Œå†²çªè§£å†³æ–¹æ³•ã€‚

#### å“ˆå¸Œå‡½æ•°

å®ç°å“ˆå¸Œè¡¨çš„å…³é”®ç‚¹åœ¨äºå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©ï¼Œå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šèƒ½å¤Ÿå†³å®šå“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚

åœ¨ç†æƒ³æƒ…å†µä¸‹ï¼Œå“ˆå¸Œå‡½æ•°åº”è¯¥èƒ½å¤Ÿå°†ä¸åŒé”®æ˜ å°„åˆ°ä¸åŒçš„ç´¢å¼•ä¸Šï¼Œè¿™è¦æ±‚**å“ˆå¸Œå‡½æ•°çš„è¾“å‡ºèŒƒå›´å¤§äºè¾“å…¥èŒƒå›´**ï¼Œä½†æ˜¯ç”±äºé”®çš„æ•°é‡ä¼šè¿œè¿œå¤§äºæ˜ å°„çš„èŒƒå›´ï¼Œæ‰€ä»¥åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œè¿™ä¸ªç†æƒ³çš„æ•ˆæœæ˜¯ä¸å¯èƒ½å®ç°çš„ã€‚

æ¯”è¾ƒå®é™…çš„æ–¹å¼æ˜¯è®©å“ˆå¸Œå‡½æ•°çš„ç»“æœèƒ½å¤Ÿå°½å¯èƒ½çš„å‡åŒ€åˆ†å¸ƒï¼Œç„¶åé€šè¿‡å·¥ç¨‹ä¸Šçš„æ‰‹æ®µè§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜ã€‚å“ˆå¸Œå‡½æ•°æ˜ å°„çš„ç»“æœä¸€å®šè¦å°½å¯èƒ½å‡åŒ€ï¼Œç»“æœä¸å‡åŒ€çš„å“ˆå¸Œå‡½æ•°ä¼šå¸¦æ¥æ›´å¤šçš„å“ˆå¸Œå†²çªä»¥åŠæ›´å·®çš„è¯»å†™æ€§èƒ½ã€‚

#### å†²çªè§£å†³

å¸¸è§æ–¹æ³•çš„å°±æ˜¯å¼€æ”¾å¯»å€æ³•å’Œæ‹‰é“¾æ³•ã€‚

##### å¼€æ”¾å¯»å€æ³•

[å¼€æ”¾å¯»å€æ³•](https://en.wikipedia.org/wiki/Open_addressing)[2](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:2)æ˜¯ä¸€ç§åœ¨å“ˆå¸Œè¡¨ä¸­è§£å†³å“ˆå¸Œç¢°æ’çš„æ–¹æ³•ï¼Œè¿™ç§æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯**ä¾æ¬¡æ¢æµ‹å’Œæ¯”è¾ƒæ•°ç»„ä¸­çš„å…ƒç´ ä»¥åˆ¤æ–­ç›®æ ‡é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­**ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨å¼€æ”¾å¯»å€æ³•æ¥å®ç°å“ˆå¸Œè¡¨ï¼Œé‚£ä¹ˆå®ç°å“ˆå¸Œè¡¨åº•å±‚çš„æ•°æ®ç»“æ„å°±æ˜¯æ•°ç»„ï¼Œä¸è¿‡å› ä¸ºæ•°ç»„çš„é•¿åº¦æœ‰é™ï¼Œå‘å“ˆå¸Œè¡¨å†™å…¥ (author, draven) è¿™ä¸ªé”®å€¼å¯¹æ—¶ä¼šä»å¦‚ä¸‹çš„ç´¢å¼•å¼€å§‹éå†ï¼š

```go
index := hash("author") % array.len
```

å½“æˆ‘ä»¬å‘å½“å‰å“ˆå¸Œè¡¨å†™å…¥æ–°çš„æ•°æ®æ—¶ï¼Œå¦‚æœå‘ç”Ÿäº†å†²çªï¼Œå°±ä¼šå°†é”®å€¼å¯¹å†™å…¥åˆ°ä¸‹ä¸€ä¸ªç´¢å¼•ä¸ä¸ºç©ºçš„ä½ç½®ï¼š

![2019-12-30-15777168478785-open-addressing-and-set](../../../images/go/2019-12-30-15777168478785-open-addressing-and-set.png)

å½“éœ€è¦æŸ¥æ‰¾æŸä¸ªé”®å¯¹åº”çš„å€¼æ—¶ï¼Œä¼šä»ç´¢å¼•çš„ä½ç½®å¼€å§‹çº¿æ€§æ¢æµ‹æ•°ç»„ï¼Œæ‰¾åˆ°ç›®æ ‡é”®å€¼å¯¹æˆ–è€…ç©ºå†…å­˜å°±æ„å‘³ç€è¿™ä¸€æ¬¡æŸ¥è¯¢æ“ä½œçš„ç»“æŸã€‚

å¼€æ”¾å¯»å€æ³•ä¸­å¯¹æ€§èƒ½å½±å“æœ€å¤§çš„æ˜¯**è£…è½½å› å­**ï¼Œå®ƒæ˜¯æ•°ç»„ä¸­å…ƒç´ çš„æ•°é‡ä¸æ•°ç»„å¤§å°çš„æ¯”å€¼ã€‚éšç€è£…è½½å› å­çš„å¢åŠ ï¼Œçº¿æ€§æ¢æµ‹çš„å¹³å‡ç”¨æ—¶å°±ä¼šé€æ¸å¢åŠ ï¼Œè¿™ä¼šå½±å“å“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚å½“è£…è½½ç‡è¶…è¿‡ 70% ä¹‹åï¼Œå“ˆå¸Œè¡¨çš„æ€§èƒ½å°±ä¼šæ€¥å‰§ä¸‹é™ï¼Œè€Œä¸€æ—¦è£…è½½ç‡è¾¾åˆ° 100%ï¼Œæ•´ä¸ªå“ˆå¸Œè¡¨å°±ä¼šå®Œå…¨å¤±æ•ˆï¼Œè¿™æ—¶æŸ¥æ‰¾å’Œæ’å…¥ä»»æ„å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(n)O(n) çš„ï¼Œè¿™æ—¶éœ€è¦éå†æ•°ç»„ä¸­çš„å…¨éƒ¨å…ƒç´ ï¼Œæ‰€ä»¥åœ¨å®ç°å“ˆå¸Œè¡¨æ—¶ä¸€å®šè¦å…³æ³¨è£…è½½å› å­çš„å˜åŒ–ã€‚

##### æ‹‰é“¾æ³•

æ‹‰é“¾æ³•æ˜¯å“ˆå¸Œè¡¨æœ€å¸¸è§çš„å®ç°æ–¹æ³•ï¼Œå¤§å¤šæ•°çš„ç¼–ç¨‹è¯­è¨€éƒ½ç”¨æ‹‰é“¾æ³•å®ç°å“ˆå¸Œè¡¨ï¼Œå®ƒçš„å®ç°æ¯”è¾ƒå¼€æ”¾åœ°å€æ³•ç¨å¾®å¤æ‚ä¸€äº›ï¼Œä½†æ˜¯å¹³å‡æŸ¥æ‰¾çš„é•¿åº¦ä¹Ÿæ¯”è¾ƒçŸ­ï¼Œå„ä¸ªç”¨äºå­˜å‚¨èŠ‚ç‚¹çš„å†…å­˜éƒ½æ˜¯åŠ¨æ€ç”³è¯·çš„ï¼Œå¯ä»¥èŠ‚çœæ¯”è¾ƒå¤šçš„å­˜å‚¨ç©ºé—´ã€‚

å®ç°æ‹‰é“¾æ³•ä¸€èˆ¬ä¼šä½¿ç”¨æ•°ç»„åŠ ä¸Šé“¾è¡¨ï¼Œä¸è¿‡ä¸€äº›ç¼–ç¨‹è¯­è¨€ä¼šåœ¨æ‹‰é“¾æ³•çš„å“ˆå¸Œä¸­å¼•å…¥çº¢é»‘æ ‘ä»¥ä¼˜åŒ–æ€§èƒ½ï¼Œæ‹‰é“¾æ³•ä¼šä½¿ç”¨é“¾è¡¨æ•°ç»„ä½œä¸ºå“ˆå¸Œåº•å±‚çš„æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒçœ‹æˆå¯ä»¥æ‰©å±•çš„äºŒç»´æ•°ç»„ï¼š

![separate-chaing-and-set](../../../images\go\2019-12-30-15777168478798-separate-chaing-and-set.png)

åœ¨ä¸€ä¸ªæ€§èƒ½æ¯”è¾ƒå¥½çš„å“ˆå¸Œè¡¨ä¸­ï¼Œæ¯ä¸€ä¸ªæ¡¶ä¸­éƒ½åº”è¯¥æœ‰ 0~1 ä¸ªå…ƒç´ ï¼Œæœ‰æ—¶ä¼šæœ‰ 2~3 ä¸ªï¼Œå¾ˆå°‘ä¼šè¶…è¿‡è¿™ä¸ªæ•°é‡ã€‚è®¡ç®—å“ˆå¸Œã€å®šä½æ¡¶å’Œéå†é“¾è¡¨ä¸‰ä¸ªè¿‡ç¨‹æ˜¯å“ˆå¸Œè¡¨è¯»å†™æ“ä½œçš„ä¸»è¦å¼€é”€ï¼Œä½¿ç”¨æ‹‰é“¾æ³•å®ç°çš„å“ˆå¸Œä¹Ÿæœ‰è£…è½½å› å­è¿™ä¸€æ¦‚å¿µï¼š
$$
è£…è½½å› å­:=å…ƒç´ æ•°é‡Ã·æ¡¶æ•°é‡
$$
ä¸å¼€æ”¾åœ°å€æ³•ä¸€æ ·ï¼Œæ‹‰é“¾æ³•çš„è£…è½½å› å­è¶Šå¤§ï¼Œå“ˆå¸Œçš„è¯»å†™æ€§èƒ½å°±è¶Šå·®ã€‚åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ä½¿ç”¨æ‹‰é“¾æ³•çš„å“ˆå¸Œè¡¨è£…è½½å› å­éƒ½ä¸ä¼šè¶…è¿‡ 1ï¼Œå½“å“ˆå¸Œè¡¨çš„è£…è½½å› å­è¾ƒå¤§æ—¶ä¼šè§¦å‘å“ˆå¸Œçš„æ‰©å®¹ï¼Œåˆ›å»ºæ›´å¤šçš„æ¡¶æ¥å­˜å‚¨å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œä¿è¯æ€§èƒ½ä¸ä¼šå‡ºç°ä¸¥é‡çš„ä¸‹é™ã€‚

### æ•°æ®ç»“æ„

Go è¯­è¨€è¿è¡Œæ—¶åŒæ—¶ä½¿ç”¨äº†å¤šä¸ªæ•°æ®ç»“æ„ç»„åˆè¡¨ç¤ºå“ˆå¸Œè¡¨ï¼Œå…¶ä¸­ [`runtime.hmap`](https://draveness.me/golang/tree/runtime.hmap) æ˜¯æœ€æ ¸å¿ƒçš„ç»“æ„ä½“ã€‚

```go
type hmap struct {
 // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
 // Make sure this stays in sync with the compiler's definition.
 count     int // # live cells == size of map.  Must be first (used by len() builtin)
 flags     uint8
 B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
 noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
 hash0     uint32 // hash seed

 buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
 oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
 nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

 extra *mapextra // optional fields
}

// mapextra holds fields that are not present on all maps.
type mapextra struct {
 // If both key and elem do not contain pointers and are inline, then we mark bucket
 // type as containing no pointers. This avoids scanning such maps.
 // However, bmap.overflow is a pointer. In order to keep overflow buckets
 // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
 // overflow and oldoverflow are only used if key and elem do not contain pointers.
 // overflow contains overflow buckets for hmap.buckets.
 // oldoverflow contains overflow buckets for hmap.oldbuckets.
 // The indirection allows to store a pointer to the slice in hiter.
 overflow    *[]*bmap
 oldoverflow *[]*bmap

 // nextOverflow holds a pointer to a free overflow bucket.
 nextOverflow *bmap
}
```

1.  `count` è¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ æ•°é‡ï¼›
2.  `B` è¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨æŒæœ‰çš„ `buckets` æ•°é‡ï¼Œä½†æ˜¯å› ä¸ºå“ˆå¸Œè¡¨ä¸­æ¡¶çš„æ•°é‡éƒ½ 2 çš„å€æ•°ï¼Œæ‰€ä»¥è¯¥å­—æ®µä¼šå­˜å‚¨å¯¹æ•°ï¼Œä¹Ÿå°±æ˜¯ `len(buckets) == 2^B`ï¼›
3.  `hash0` æ˜¯å“ˆå¸Œçš„ç§å­ï¼Œå®ƒèƒ½ä¸ºå“ˆå¸Œå‡½æ•°çš„ç»“æœå¼•å…¥éšæœºæ€§ï¼Œè¿™ä¸ªå€¼åœ¨åˆ›å»ºå“ˆå¸Œè¡¨æ—¶ç¡®å®šï¼Œå¹¶åœ¨è°ƒç”¨å“ˆå¸Œå‡½æ•°æ—¶ä½œä¸ºå‚æ•°ä¼ å…¥ï¼›
4.  `oldbuckets` æ˜¯å“ˆå¸Œåœ¨æ‰©å®¹æ—¶ç”¨äºä¿å­˜ä¹‹å‰ `buckets` çš„å­—æ®µï¼Œå®ƒçš„å¤§å°æ˜¯å½“å‰ `buckets` çš„ä¸€åŠï¼›

![hmap-and-buckets](..\..\..\images\go\hmap-and-buckets.png)

å“ˆå¸Œè¡¨ [`runtime.hmap`](https://draveness.me/golang/tree/runtime.hmap) çš„æ¡¶æ˜¯ [`runtime.bmap`](https://draveness.me/golang/tree/runtime.bmap)ã€‚æ¯ä¸€ä¸ª [`runtime.bmap`](https://draveness.me/golang/tree/runtime.bmap) éƒ½èƒ½å­˜å‚¨ 8 ä¸ªé”®å€¼å¯¹ï¼Œå½“å“ˆå¸Œè¡¨ä¸­å­˜å‚¨çš„æ•°æ®è¿‡å¤šï¼Œå•ä¸ªæ¡¶å·²ç»è£…æ»¡æ—¶å°±ä¼šä½¿ç”¨ `extra.nextOverflow` ä¸­æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ã€‚

ä¸Šè¿°ä¸¤ç§ä¸åŒçš„æ¡¶åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå°†å®ƒä»¬åˆ†åˆ«ç§°ä¸ºæ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ï¼Œä¸Šå›¾ä¸­é»„è‰²çš„ [`runtime.bmap`](https://draveness.me/golang/tree/runtime.bmap) å°±æ˜¯æ­£å¸¸æ¡¶ï¼Œç»¿è‰²çš„ [`runtime.bmap`](https://draveness.me/golang/tree/runtime.bmap) æ˜¯æº¢å‡ºæ¡¶ï¼Œæº¢å‡ºæ¡¶æ˜¯åœ¨ Go è¯­è¨€è¿˜ä½¿ç”¨ C è¯­è¨€å®ç°æ—¶ä½¿ç”¨çš„è®¾è®¡[3](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:3)ï¼Œç”±äºå®ƒèƒ½å¤Ÿå‡å°‘æ‰©å®¹çš„é¢‘ç‡æ‰€ä»¥ä¸€ç›´ä½¿ç”¨è‡³ä»Šã€‚

æ¡¶çš„ç»“æ„ä½“ [`runtime.bmap`](https://draveness.me/golang/tree/runtime.bmap) åœ¨ Go è¯­è¨€æºä»£ç ä¸­çš„å®šä¹‰åªåŒ…å«ä¸€ä¸ªç®€å•çš„ `tophash` å­—æ®µï¼Œ`tophash` å­˜å‚¨äº†é”®çš„å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œé€šè¿‡æ¯”è¾ƒä¸åŒé”®çš„å“ˆå¸Œçš„é«˜ 8 ä½å¯ä»¥å‡å°‘è®¿é—®é”®å€¼å¯¹æ¬¡æ•°ä»¥æé«˜æ€§èƒ½ï¼š

```go
type bmap struct {
 tophash [bucketCnt]uint8
}
```

åœ¨è¿è¡ŒæœŸé—´ï¼Œ[`runtime.bmap`](https://draveness.me/golang/tree/runtime.bmap) ç»“æ„ä½“å…¶å®ä¸æ­¢åŒ…å« `tophash` å­—æ®µï¼Œå› ä¸ºå“ˆå¸Œè¡¨ä¸­å¯èƒ½å­˜å‚¨ä¸åŒç±»å‹çš„é”®å€¼å¯¹ï¼Œè€Œä¸” Go è¯­è¨€ä¹Ÿä¸æ”¯æŒæ³›å‹ï¼Œæ‰€ä»¥é”®å€¼å¯¹å æ®çš„å†…å­˜ç©ºé—´å¤§å°åªèƒ½åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ¨å¯¼ã€‚

[`runtime.bmap`](https://draveness.me/golang/tree/runtime.bmap) ä¸­çš„å…¶ä»–å­—æ®µåœ¨è¿è¡Œæ—¶ä¹Ÿéƒ½æ˜¯é€šè¿‡è®¡ç®—å†…å­˜åœ°å€çš„æ–¹å¼è®¿é—®çš„ï¼Œæ‰€ä»¥å®ƒçš„å®šä¹‰ä¸­å°±ä¸åŒ…å«è¿™äº›å­—æ®µï¼Œä¸è¿‡æˆ‘ä»¬èƒ½æ ¹æ®ç¼–è¯‘æœŸé—´çš„ [`cmd/compile/internal/gc.bmap`](https://draveness.me/golang/tree/cmd/compile/internal/gc.bmap) å‡½æ•°é‡å»ºå®ƒçš„ç»“æ„ï¼š

```go
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
```

éšç€å“ˆå¸Œè¡¨å­˜å‚¨çš„æ•°æ®é€æ¸å¢å¤šï¼Œä¼šæ‰©å®¹å“ˆå¸Œè¡¨æˆ–è€…ä½¿ç”¨é¢å¤–çš„æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ï¼Œä¸ä¼šè®©å•ä¸ªæ¡¶ä¸­çš„æ•°æ®è¶…è¿‡ 8 ä¸ªï¼Œä¸è¿‡æº¢å‡ºæ¡¶åªæ˜¯ä¸´æ—¶çš„è§£å†³æ–¹æ¡ˆï¼Œåˆ›å»ºè¿‡å¤šçš„æº¢å‡ºæ¡¶æœ€ç»ˆä¹Ÿä¼šå¯¼è‡´å“ˆå¸Œçš„æ‰©å®¹ã€‚

ä» Go è¯­è¨€å“ˆå¸Œçš„å®šä¹‰ä¸­å¯ä»¥å‘ç°ï¼Œæ”¹è¿›å…ƒç´ æ¯”æ•°ç»„å’Œåˆ‡ç‰‡å¤æ‚å¾—å¤šï¼Œå®ƒçš„ç»“æ„ä½“ä¸­ä¸ä»…åŒ…å«å¤§é‡å­—æ®µï¼Œè¿˜ä½¿ç”¨å¤æ‚çš„åµŒå¥—ç»“æ„ï¼Œåé¢çš„å°èŠ‚ä¼šè¯¦ç»†ä»‹ç»ä¸åŒå­—æ®µçš„ä½œç”¨ã€‚

### åˆå§‹åŒ–

#### å­—é¢é‡

ç›®å‰çš„ç°ä»£ç¼–ç¨‹è¯­è¨€åŸºæœ¬éƒ½æ”¯æŒä½¿ç”¨å­—é¢é‡çš„æ–¹å¼åˆå§‹åŒ–å“ˆå¸Œï¼Œä¸€èˆ¬éƒ½ä¼šä½¿ç”¨ `key: value` çš„è¯­æ³•æ¥è¡¨ç¤ºé”®å€¼å¯¹ï¼ŒGo è¯­è¨€ä¸­ä¹Ÿä¸ä¾‹å¤–ï¼š

```go
hash := map[string]int{
 "1": 2,
 "3": 4,
 "5": 6,
}
```

æˆ‘ä»¬éœ€è¦åœ¨åˆå§‹åŒ–å“ˆå¸Œæ—¶å£°æ˜é”®å€¼å¯¹çš„ç±»å‹ï¼Œè¿™ç§ä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–çš„æ–¹å¼æœ€ç»ˆéƒ½ä¼šé€šè¿‡ [`cmd/compile/internal/gc.maplit`](https://draveness.me/golang/tree/cmd/compile/internal/gc.maplit) åˆå§‹åŒ–ï¼Œæˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹è¯¥å‡½æ•°åˆå§‹åŒ–å“ˆå¸Œçš„è¿‡ç¨‹ï¼š

```go
func maplit(n *Node, m *Node, init *Nodes) {
 a := nod(OMAKE, nil, nil)
 a.Esc = n.Esc
 a.List.Set2(typenod(n.Type), nodintconst(int64(n.List.Len())))
 litas(m, a, init)

 entries := n.List.Slice()
 if len(entries) > 25 {
  ...
  return
 }

 // Build list of var[c] = expr.
 // Use temporaries so that mapassign1 can have addressable key, elem.
 ...
}
```

å½“å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ æ•°é‡å°‘äºæˆ–è€…ç­‰äº 25 ä¸ªæ—¶ï¼Œç¼–è¯‘å™¨ä¼šå°†å­—é¢é‡åˆå§‹åŒ–çš„ç»“æ„ä½“è½¬æ¢æˆä»¥ä¸‹çš„ä»£ç ï¼Œå°†æ‰€æœ‰çš„é”®å€¼å¯¹ä¸€æ¬¡åŠ å…¥åˆ°å“ˆå¸Œè¡¨ä¸­ï¼š

```go
hash := make(map[string]int, 3)
hash["1"] = 2
hash["3"] = 4
hash["5"] = 6
```

è¿™ç§åˆå§‹åŒ–çš„æ–¹å¼ä¸çš„[æ•°ç»„](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/)å’Œ[åˆ‡ç‰‡](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/)å‡ ä¹å®Œå…¨ç›¸åŒï¼Œç”±æ­¤çœ‹æ¥é›†åˆç±»å‹çš„åˆå§‹åŒ–åœ¨ Go è¯­è¨€ä¸­æœ‰ç€ç›¸åŒçš„å¤„ç†é€»è¾‘ã€‚

ä¸€æ—¦å“ˆå¸Œè¡¨ä¸­å…ƒç´ çš„æ•°é‡è¶…è¿‡äº† 25 ä¸ªï¼Œç¼–è¯‘å™¨ä¼šåˆ›å»ºä¸¤ä¸ªæ•°ç»„åˆ†åˆ«å­˜å‚¨é”®å’Œå€¼ï¼Œè¿™äº›é”®å€¼å¯¹ä¼šé€šè¿‡å¦‚ä¸‹æ‰€ç¤ºçš„ for å¾ªç¯åŠ å…¥å“ˆå¸Œï¼š

```go
hash := make(map[string]int, 26)
vstatk := []string{"1", "2", "3", ... ï¼Œ "26"}
vstatv := []int{1, 2, 3, ... , 26}
for i := 0; i < len(vstak); i++ {
    hash[vstatk[i]] = vstatv[i]
}
```

è¿™é‡Œå±•å¼€çš„ä¸¤ä¸ªåˆ‡ç‰‡ `vstatk` å’Œ `vstatv` è¿˜ä¼šè¢«ç¼–è¾‘å™¨ç»§ç»­å±•å¼€ï¼Œå…·ä½“çš„å±•å¼€æ–¹å¼å¯ä»¥é˜…è¯»ä¸Šä¸€èŠ‚äº†è§£[åˆ‡ç‰‡çš„åˆå§‹åŒ–](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/)ï¼Œä¸è¿‡æ— è®ºä½¿ç”¨å“ªç§æ–¹æ³•ï¼Œä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–çš„è¿‡ç¨‹éƒ½ä¼šä½¿ç”¨ Go è¯­è¨€ä¸­çš„å…³é”®å­— `make` æ¥åˆ›å»ºæ–°çš„å“ˆå¸Œå¹¶é€šè¿‡æœ€åŸå§‹çš„ `[]` è¯­æ³•å‘å“ˆå¸Œè¿½åŠ å…ƒç´ ã€‚

#### è¿è¡Œæ—¶

å½“åˆ›å»ºçš„å“ˆå¸Œè¢«åˆ†é…åˆ°æ ˆä¸Šå¹¶ä¸”å…¶å®¹é‡å°äº `BUCKETSIZE = 8` æ—¶ï¼ŒGo è¯­è¨€åœ¨ç¼–è¯‘é˜¶æ®µä¼šä½¿ç”¨å¦‚ä¸‹æ–¹å¼å¿«é€Ÿåˆå§‹åŒ–å“ˆå¸Œï¼Œè¿™ä¹Ÿæ˜¯ç¼–è¯‘å™¨å¯¹å°å®¹é‡çš„å“ˆå¸Œåšçš„ä¼˜åŒ–ï¼š

```go
var h *hmap
var hv hmap
var bv bmap
h := &hv
b := &bv
h.buckets = b
h.hash0 = fashtrand0()
```

é™¤äº†ä¸Šè¿°ç‰¹å®šçš„ä¼˜åŒ–ä¹‹å¤–ï¼Œæ— è®º `make` æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Œåªè¦æˆ‘ä»¬ä½¿ç”¨ `make` åˆ›å»ºå“ˆå¸Œï¼ŒGo è¯­è¨€ç¼–è¯‘å™¨éƒ½ä¼šåœ¨[ç±»å‹æ£€æŸ¥](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/)æœŸé—´å°†å®ƒä»¬è½¬æ¢æˆ [`runtime.makemap`](https://draveness.me/golang/tree/runtime.makemap)ï¼Œä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–å“ˆå¸Œä¹Ÿåªæ˜¯è¯­è¨€æä¾›çš„è¾…åŠ©å·¥å…·ï¼Œæœ€åè°ƒç”¨çš„éƒ½æ˜¯ [`runtime.makemap`](https://draveness.me/golang/tree/runtime.makemap)ï¼š

```go
func makemap(t *maptype, hint int, h *hmap) *hmap {
	mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
	if overflow || mem > maxAlloc {
		hint = 0
	}

	if h == nil {
		h = new(hmap)
	}
	h.hash0 = fastrand()

	B := uint8(0)
	for overLoadFactor(hint, B) {
		B++
	}
	h.B = B

	if h.B != 0 {
		var nextOverflow *bmap
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
		if nextOverflow != nil {
			h.extra = new(mapextra)
			h.extra.nextOverflow = nextOverflow
		}
	}
	return h
}
```

è¿™ä¸ªå‡½æ•°ä¼šæŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤æ‰§è¡Œï¼š

1. è®¡ç®—å“ˆå¸Œå ç”¨çš„å†…å­˜æ˜¯å¦æº¢å‡ºæˆ–è€…è¶…å‡ºèƒ½åˆ†é…çš„æœ€å¤§å€¼ï¼›
2. è°ƒç”¨ [`runtime.fastrand`](https://draveness.me/golang/tree/runtime.fastrand) è·å–ä¸€ä¸ªéšæœºçš„å“ˆå¸Œç§å­ï¼›
3. æ ¹æ®ä¼ å…¥çš„ `hint` è®¡ç®—å‡ºéœ€è¦çš„æœ€å°éœ€è¦çš„æ¡¶çš„æ•°é‡ï¼›
4. ä½¿ç”¨ [`runtime.makeBucketArray`](https://draveness.me/golang/tree/runtime.makeBucketArray) åˆ›å»ºç”¨äºä¿å­˜æ¡¶çš„æ•°ç»„ï¼›

[`runtime.makeBucketArray`](https://draveness.me/golang/tree/runtime.makeBucketArray) ä¼šæ ¹æ®ä¼ å…¥çš„ `B` è®¡ç®—å‡ºçš„éœ€è¦åˆ›å»ºçš„æ¡¶æ•°é‡å¹¶åœ¨å†…å­˜ä¸­åˆ†é…ä¸€ç‰‡è¿ç»­çš„ç©ºé—´ç”¨äºå­˜å‚¨æ•°æ®ï¼š

```go
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
	base := bucketShift(b)
	nbuckets := base
	if b >= 4 {
		nbuckets += bucketShift(b - 4)
		sz := t.bucket.size * nbuckets
		up := roundupsize(sz)
		if up != sz {
			nbuckets = up / t.bucket.size
		}
	}

	buckets = newarray(t.bucket, int(nbuckets))
	if base != nbuckets {
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
		last.setoverflow(t, (*bmap)(buckets))
	}
	return buckets, nextOverflow
}
```

- å½“æ¡¶çš„æ•°é‡å°äº 2424 æ—¶ï¼Œç”±äºæ•°æ®è¾ƒå°‘ã€ä½¿ç”¨æº¢å‡ºæ¡¶çš„å¯èƒ½æ€§è¾ƒä½ï¼Œä¼šçœç•¥åˆ›å»ºçš„è¿‡ç¨‹ä»¥å‡å°‘é¢å¤–å¼€é”€ï¼›
- å½“æ¡¶çš„æ•°é‡å¤šäº 2424 æ—¶ï¼Œä¼šé¢å¤–åˆ›å»º 2ğµâˆ’42Bâˆ’4 ä¸ªæº¢å‡ºæ¡¶ï¼›

æ ¹æ®ä¸Šè¿°ä»£ç ï¼Œæˆ‘ä»¬èƒ½ç¡®å®šåœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œæ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸­çš„å­˜å‚¨ç©ºé—´æ˜¯è¿ç»­çš„ï¼Œåªæ˜¯è¢« [`runtime.hmap`](https://draveness.me/golang/tree/runtime.hmap) ä¸­çš„ä¸åŒå­—æ®µå¼•ç”¨ï¼Œå½“æº¢å‡ºæ¡¶æ•°é‡è¾ƒå¤šæ—¶ä¼šé€šè¿‡ [`runtime.newobject`](https://draveness.me/golang/tree/runtime.newobject) åˆ›å»ºæ–°çš„æº¢å‡ºæ¡¶ã€‚

### è¯»å†™æ“ä½œ

å“ˆå¸Œè¡¨çš„è®¿é—®ä¸€èˆ¬éƒ½æ˜¯é€šè¿‡ä¸‹æ ‡æˆ–è€…éå†è¿›è¡Œçš„ï¼š

```go
_ = hash[key]

for k, v := range hash {
    // k, v
}
```

åœ¨è¿™é‡Œæˆ‘ä»¬ä¼šä»‹ç»å‰ä¸€ç§è®¿é—®æ–¹å¼ï¼Œç¬¬äºŒç§è®¿é—®æ–¹å¼ä¼šåœ¨ `range` ä¸€èŠ‚ä¸­è¯¦ç»†åˆ†æã€‚

æ•°æ®ç»“æ„çš„å†™ä¸€èˆ¬æŒ‡çš„éƒ½æ˜¯å¢åŠ ã€åˆ é™¤å’Œä¿®æ”¹ï¼Œå¢åŠ å’Œä¿®æ”¹å­—æ®µéƒ½ä½¿ç”¨ç´¢å¼•å’Œèµ‹å€¼è¯­å¥ï¼Œè€Œåˆ é™¤å­—å…¸ä¸­çš„æ•°æ®éœ€è¦ä½¿ç”¨å…³é”®å­— `delete`ï¼š

```go
hash[key] = value
hash[key] = newValue
delete(hash, key)
```

#### è®¿é—®

åœ¨ç¼–è¯‘çš„[ç±»å‹æ£€æŸ¥](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/)æœŸé—´ï¼Œ`hash[key]` ä»¥åŠç±»ä¼¼çš„æ“ä½œéƒ½ä¼šè¢«è½¬æ¢æˆå“ˆå¸Œçš„ `OINDEXMAP` æ“ä½œï¼Œ[ä¸­é—´ä»£ç ç”Ÿæˆ](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/)é˜¶æ®µä¼šåœ¨ [`cmd/compile/internal/gc.walkexpr`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr) å‡½æ•°ä¸­å°†è¿™äº› `OINDEXMAP` æ“ä½œè½¬æ¢æˆå¦‚ä¸‹çš„ä»£ç ï¼š

```go
v     := hash[key] // => v     := *mapaccess1(maptype, hash, &key)
v, ok := hash[key] // => v, ok := mapaccess2(maptype, hash, &key)
```

èµ‹å€¼è¯­å¥å·¦ä¾§æ¥å—å‚æ•°çš„ä¸ªæ•°ä¼šå†³å®šä½¿ç”¨çš„è¿è¡Œæ—¶æ–¹æ³•ï¼š

- å½“æ¥å—ä¸€ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ [`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1)ï¼Œè¯¥å‡½æ•°ä»…ä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘ç›®æ ‡å€¼çš„æŒ‡é’ˆï¼›
- å½“æ¥å—ä¸¤ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ [`runtime.mapaccess2`](https://draveness.me/golang/tree/runtime.mapaccess2)ï¼Œé™¤äº†è¿”å›ç›®æ ‡å€¼ä¹‹å¤–ï¼Œå®ƒè¿˜ä¼šè¿”å›ä¸€ä¸ªç”¨äºè¡¨ç¤ºå½“å‰é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨çš„ `bool` å€¼ï¼š

[`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1) ä¼šå…ˆé€šè¿‡å“ˆå¸Œè¡¨è®¾ç½®çš„å“ˆå¸Œå‡½æ•°ã€ç§å­è·å–å½“å‰é”®å¯¹åº”çš„å“ˆå¸Œï¼Œå†é€šè¿‡ [`runtime.bucketMask`](https://draveness.me/golang/tree/runtime.bucketMask) å’Œ [`runtime.add`](https://draveness.me/golang/tree/runtime.add) æ‹¿åˆ°è¯¥é”®å€¼å¯¹æ‰€åœ¨çš„æ¡¶åºå·å’Œå“ˆå¸Œé«˜ä½çš„ 8 ä½æ•°å­—ã€‚

```go
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	alg := t.key.alg
	hash := alg.hash(key, uintptr(h.hash0))
	m := bucketMask(h.B)
	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
	top := tophash(hash)
bucketloop:
	for ; b != nil; b = b.overflow(t) {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if alg.equal(key, k) {
				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
				return v
			}
		}
	}
	return unsafe.Pointer(&zeroVal[0])
}
```

åœ¨ `bucketloop` å¾ªç¯ä¸­ï¼Œå“ˆå¸Œä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­çš„æ•°æ®ï¼Œå®ƒä¼šå…ˆæ¯”è¾ƒå“ˆå¸Œçš„é«˜ 8 ä½å’Œæ¡¶ä¸­å­˜å‚¨çš„ `tophash`ï¼Œåæ¯”è¾ƒä¼ å…¥çš„å’Œæ¡¶ä¸­çš„å€¼ä»¥åŠ é€Ÿæ•°æ®çš„è¯»å†™ã€‚ç”¨äºé€‰æ‹©æ¡¶åºå·çš„æ˜¯å“ˆå¸Œçš„æœ€ä½å‡ ä½ï¼Œè€Œç”¨äºåŠ é€Ÿè®¿é—®çš„æ˜¯å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œè¿™ç§è®¾è®¡èƒ½å¤Ÿå‡å°‘åŒä¸€ä¸ªæ¡¶ä¸­æœ‰å¤§é‡ç›¸ç­‰ `tophash` çš„æ¦‚ç‡å½±å“æ€§èƒ½ã€‚

![hashmap-mapaccess](../../../images/go/hashmap-mapaccess.png)

**å›¾ 3-13 è®¿é—®å“ˆå¸Œè¡¨ä¸­çš„æ•°æ®**

å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ¯ä¸€ä¸ªæ¡¶éƒ½æ˜¯ä¸€æ•´ç‰‡çš„å†…å­˜ç©ºé—´ï¼Œå½“å‘ç°æ¡¶ä¸­çš„ `tophash` ä¸ä¼ å…¥é”®çš„ `tophash` åŒ¹é…ä¹‹åï¼Œæˆ‘ä»¬ä¼šé€šè¿‡æŒ‡é’ˆå’Œåç§»é‡è·å–å“ˆå¸Œä¸­å­˜å‚¨çš„é”® `keys[0]` å¹¶ä¸ `key` æ¯”è¾ƒï¼Œå¦‚æœä¸¤è€…ç›¸åŒå°±ä¼šè·å–ç›®æ ‡å€¼çš„æŒ‡é’ˆ `values[0]` å¹¶è¿”å›ã€‚

å¦ä¸€ä¸ªåŒæ ·ç”¨äºè®¿é—®å“ˆå¸Œè¡¨ä¸­æ•°æ®çš„ [`runtime.mapaccess2`](https://draveness.me/golang/tree/runtime.mapaccess2) åªæ˜¯åœ¨ [`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1) çš„åŸºç¡€ä¸Šå¤šè¿”å›äº†ä¸€ä¸ªæ ‡è¯†é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨çš„ `bool` å€¼ï¼š

```go
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {
	...
bucketloop:
	for ; b != nil; b = b.overflow(t) {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if alg.equal(key, k) {
				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
				return v, true
			}
		}
	}
	return unsafe.Pointer(&zeroVal[0]), false
}
```

#### å†™å…¥

å½“å½¢å¦‚ `hash[k]` çš„è¡¨è¾¾å¼å‡ºç°åœ¨èµ‹å€¼ç¬¦å·å·¦ä¾§æ—¶ï¼Œè¯¥è¡¨è¾¾å¼ä¹Ÿä¼šåœ¨ç¼–è¯‘æœŸé—´è½¬æ¢æˆ [`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) å‡½æ•°çš„è°ƒç”¨ï¼Œè¯¥å‡½æ•°ä¸ [`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1) æ¯”è¾ƒç›¸ä¼¼ï¼Œé¦–å…ˆæ˜¯å‡½æ•°ä¼šæ ¹æ®ä¼ å…¥çš„é”®æ‹¿åˆ°å¯¹åº”çš„å“ˆå¸Œå’Œæ¡¶ï¼š

```go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	alg := t.key.alg
	hash := alg.hash(key, uintptr(h.hash0))

	h.flags ^= hashWriting

again:
	bucket := hash & bucketMask(h.B)
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
	top := tophash(hash)
```

ç„¶åé€šè¿‡éå†æ¯”è¾ƒæ¡¶ä¸­å­˜å‚¨çš„ `tophash` å’Œé”®çš„å“ˆå¸Œï¼Œå¦‚æœæ‰¾åˆ°äº†ç›¸åŒç»“æœå°±ä¼šè¿”å›ç›®æ ‡ä½ç½®çš„åœ°å€ã€‚å…¶ä¸­ `inserti` è¡¨ç¤ºç›®æ ‡å…ƒç´ çš„åœ¨æ¡¶ä¸­çš„ç´¢å¼•ï¼Œ`insertk` å’Œ `val` åˆ†åˆ«è¡¨ç¤ºé”®å€¼å¯¹çš„åœ°å€ï¼Œè·å¾—ç›®æ ‡åœ°å€ä¹‹åä¼šé€šè¿‡ç®—æœ¯è®¡ç®—å¯»å€è·å¾—é”®å€¼å¯¹ `k` å’Œ `val`ï¼š

```go
  var inserti *uint8
	var insertk unsafe.Pointer
	var val unsafe.Pointer
bucketloop:
	for {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if isEmpty(b.tophash[i]) && inserti == nil {
					inserti = &b.tophash[i]
					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
				}
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if !alg.equal(key, k) {
				continue
			}
			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
			goto done
		}
		ovf := b.overflow(t)
		if ovf == nil {
			break
		}
		b = ovf
	}
```

ä¸Šè¿°çš„ for å¾ªç¯ä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­å­˜å‚¨çš„æ•°æ®ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¼šåˆ†åˆ«åˆ¤æ–­ `tophash` æ˜¯å¦ç›¸ç­‰ã€`key` æ˜¯å¦ç›¸ç­‰ï¼Œéå†ç»“æŸåä¼šä»å¾ªç¯ä¸­è·³å‡ºã€‚

![hashmap-overflow-bucket](../../../images/go/hashmap-overflow-bucket.png)

**å›¾ 3-15 å“ˆå¸Œéå†æº¢å‡ºæ¡¶**

å¦‚æœå½“å‰æ¡¶å·²ç»æ»¡äº†ï¼Œå“ˆå¸Œä¼šè°ƒç”¨ [`runtime.hmap.newoverflow`](https://draveness.me/golang/tree/runtime.hmap.newoverflow) åˆ›å»ºæ–°æ¡¶æˆ–è€…ä½¿ç”¨ [`runtime.hmap`](https://draveness.me/golang/tree/runtime.hmap) é¢„å…ˆåœ¨ `noverflow` ä¸­åˆ›å»ºå¥½çš„æ¡¶æ¥ä¿å­˜æ•°æ®ï¼Œæ–°åˆ›å»ºçš„æ¡¶ä¸ä»…ä¼šè¢«è¿½åŠ åˆ°å·²æœ‰æ¡¶çš„æœ«å°¾ï¼Œè¿˜ä¼šå¢åŠ å“ˆå¸Œè¡¨çš„ `noverflow` è®¡æ•°å™¨ã€‚

```go
	if inserti == nil {
		newb := h.newoverflow(t, b)
		inserti = &newb.tophash[0]
		insertk = add(unsafe.Pointer(newb), dataOffset)
		val = add(insertk, bucketCnt*uintptr(t.keysize))
	}

	typedmemmove(t.key, insertk, key)
	*inserti = top
	h.count++

done:
	return val
}
```

å¦‚æœå½“å‰é”®å€¼å¯¹åœ¨å“ˆå¸Œä¸­ä¸å­˜åœ¨ï¼Œå“ˆå¸Œä¼šä¸ºæ–°é”®å€¼å¯¹è§„åˆ’å­˜å‚¨çš„å†…å­˜åœ°å€ï¼Œé€šè¿‡ [`runtime.typedmemmove`](https://draveness.me/golang/tree/runtime.typedmemmove) å°†é”®ç§»åŠ¨åˆ°å¯¹åº”çš„å†…å­˜ç©ºé—´ä¸­å¹¶è¿”å›é”®å¯¹åº”å€¼çš„åœ°å€ `val`ã€‚å¦‚æœå½“å‰é”®å€¼å¯¹åœ¨å“ˆå¸Œä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆå°±ä¼šç›´æ¥è¿”å›ç›®æ ‡åŒºåŸŸçš„å†…å­˜åœ°å€ï¼Œå“ˆå¸Œå¹¶ä¸ä¼šåœ¨ [`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) è¿™ä¸ªè¿è¡Œæ—¶å‡½æ•°ä¸­å°†å€¼æ‹·è´åˆ°æ¡¶ä¸­ï¼Œè¯¥å‡½æ•°åªä¼šè¿”å›å†…å­˜åœ°å€ï¼ŒçœŸæ­£çš„èµ‹å€¼æ“ä½œæ˜¯åœ¨ç¼–è¯‘æœŸé—´æ’å…¥çš„ï¼š

```go
00018 (+5) CALL runtime.mapassign_fast64(SB)
00020 (5) MOVQ 24(SP), DI               ;; DI = &value
00026 (5) LEAQ go.string."88"(SB), AX   ;; AX = &"88"
00027 (5) MOVQ AX, (DI)                 ;; *DI = AX
```

[`runtime.mapassign_fast64`](https://draveness.me/golang/tree/runtime.mapassign_fast64) ä¸ [`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) å‡½æ•°çš„é€»è¾‘å·®ä¸å¤šï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨çš„æ˜¯åé¢çš„ä¸‰è¡Œä»£ç ï¼Œå…¶ä¸­ `24(SP)` æ˜¯è¯¥å‡½æ•°è¿”å›çš„å€¼åœ°å€ï¼Œæˆ‘ä»¬é€šè¿‡ `LEAQ` æŒ‡ä»¤å°†å­—ç¬¦ä¸²çš„åœ°å€å­˜å‚¨åˆ°å¯„å­˜å™¨ `AX` ä¸­ï¼Œ`MOVQ` æŒ‡ä»¤å°†å­—ç¬¦ä¸² `"88"` å­˜å‚¨åˆ°äº†ç›®æ ‡åœ°å€ä¸Šå®Œæˆäº†è¿™æ¬¡å“ˆå¸Œçš„å†™å…¥ã€‚

#### æ‰©å®¹

```go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	...
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
		hashGrow(t, h)
		goto again
	}
	...
}
```

[`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) å‡½æ•°ä¼šåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µå‘ç”Ÿæ—¶è§¦å‘å“ˆå¸Œçš„æ‰©å®¹ï¼š

1. è£…è½½å› å­å·²ç»è¶…è¿‡ 6.5ï¼›
2. å“ˆå¸Œä½¿ç”¨äº†å¤ªå¤šæº¢å‡ºæ¡¶ï¼›

å› ä¸º Go è¯­è¨€å“ˆå¸Œçš„æ‰©å®¹ä¸æ˜¯ä¸€ä¸ªåŸå­çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥ [`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) è¿˜éœ€è¦åˆ¤æ–­å½“å‰å“ˆå¸Œæ˜¯å¦å·²ç»å¤„äºæ‰©å®¹çŠ¶æ€ï¼Œé¿å…äºŒæ¬¡æ‰©å®¹é€ æˆæ··ä¹±ã€‚

æ ¹æ®è§¦å‘çš„æ¡ä»¶ä¸åŒæ‰©å®¹çš„æ–¹å¼åˆ†æˆä¸¤ç§ï¼Œå¦‚æœè¿™æ¬¡æ‰©å®¹æ˜¯æº¢å‡ºçš„æ¡¶å¤ªå¤šå¯¼è‡´çš„ï¼Œé‚£ä¹ˆè¿™æ¬¡æ‰©å®¹å°±æ˜¯ç­‰é‡æ‰©å®¹ `sameSizeGrow`ï¼Œ`sameSizeGrow` æ˜¯ä¸€ç§ç‰¹æ®Šæƒ…å†µä¸‹å‘ç”Ÿçš„æ‰©å®¹ï¼Œå½“æˆ‘ä»¬æŒç»­å‘å“ˆå¸Œä¸­æ’å…¥æ•°æ®å¹¶å°†å®ƒä»¬å…¨éƒ¨åˆ é™¤æ—¶ï¼Œå¦‚æœå“ˆå¸Œè¡¨ä¸­çš„æ•°æ®é‡æ²¡æœ‰è¶…è¿‡é˜ˆå€¼ï¼Œå°±ä¼šä¸æ–­ç§¯ç´¯æº¢å‡ºæ¡¶é€ æˆç¼“æ…¢çš„å†…å­˜æ³„æ¼[4](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:4)ã€‚[runtime: limit the number of map overflow buckets](https://github.com/golang/go/commit/9980b70cb460f27907a003674ab1b9bea24a847c) å¼•å…¥äº† `sameSizeGrow` é€šè¿‡å¤ç”¨å·²æœ‰çš„å“ˆå¸Œæ‰©å®¹æœºåˆ¶è§£å†³è¯¥é—®é¢˜ï¼Œä¸€æ—¦å“ˆå¸Œä¸­å‡ºç°äº†è¿‡å¤šçš„æº¢å‡ºæ¡¶ï¼Œå®ƒä¼šåˆ›å»ºæ–°æ¡¶ä¿å­˜æ•°æ®ï¼Œåƒåœ¾å›æ”¶ä¼šæ¸…ç†è€çš„æº¢å‡ºæ¡¶å¹¶é‡Šæ”¾å†…å­˜ã€‚

æ‰©å®¹çš„å…¥å£æ˜¯ [`runtime.hashGrow`](https://draveness.me/golang/tree/runtime.hashGrow)ï¼š

```go
func hashGrow(t *maptype, h *hmap) {
	bigger := uint8(1)
	if !overLoadFactor(h.count+1, h.B) {
		bigger = 0
		h.flags |= sameSizeGrow
	}
	oldbuckets := h.buckets
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)

	h.B += bigger
	h.flags = flags
	h.oldbuckets = oldbuckets
	h.buckets = newbuckets
	h.nevacuate = 0
	h.noverflow = 0

	h.extra.oldoverflow = h.extra.overflow
	h.extra.overflow = nil
	h.extra.nextOverflow = nextOverflow
}
```

å“ˆå¸Œåœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ä¼šé€šè¿‡ [`runtime.makeBucketArray`](https://draveness.me/golang/tree/runtime.makeBucketArray) åˆ›å»ºä¸€ç»„æ–°æ¡¶å’Œé¢„åˆ›å»ºçš„æº¢å‡ºæ¡¶ï¼Œéšåå°†åŸæœ‰çš„æ¡¶æ•°ç»„è®¾ç½®åˆ° `oldbuckets` ä¸Šå¹¶å°†æ–°çš„ç©ºæ¡¶è®¾ç½®åˆ° `buckets` ä¸Šï¼Œæº¢å‡ºæ¡¶ä¹Ÿä½¿ç”¨äº†ç›¸åŒçš„é€»è¾‘æ›´æ–°ã€‚

![hashmap-hashgrow](../../../images/go/hashmap-hashgrow.png)

**å“ˆå¸Œè¡¨è§¦å‘æ‰©å®¹**

åœ¨ [`runtime.hashGrow`](https://draveness.me/golang/tree/runtime.hashGrow) ä¸­è¿˜çœ‹ä¸å‡ºæ¥ç­‰é‡æ‰©å®¹å’Œç¿»å€æ‰©å®¹çš„å¤ªå¤šåŒºåˆ«ï¼Œç­‰é‡æ‰©å®¹åˆ›å»ºçš„æ–°æ¡¶æ•°é‡åªæ˜¯å’Œæ—§æ¡¶ä¸€æ ·ï¼Œè¯¥å‡½æ•°ä¸­åªæ˜¯åˆ›å»ºäº†æ–°çš„æ¡¶ï¼Œå¹¶æ²¡æœ‰å¯¹æ•°æ®è¿›è¡Œæ‹·è´å’Œè½¬ç§»ã€‚å“ˆå¸Œè¡¨çš„æ•°æ®è¿ç§»çš„è¿‡ç¨‹åœ¨æ˜¯ [`runtime.evacuate`](https://draveness.me/golang/tree/runtime.evacuate) ä¸­å®Œæˆçš„ï¼Œå®ƒä¼šå¯¹ä¼ å…¥æ¡¶ä¸­çš„å…ƒç´ è¿›è¡Œå†åˆ†é…ã€‚

```go
func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
	b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
	newbit := h.noldbuckets()
	if !evacuated(b) {
		var xy [2]evacDst
		x := &xy[0]
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
		x.k = add(unsafe.Pointer(x.b), dataOffset)
		x.v = add(x.k, bucketCnt*uintptr(t.keysize))

		y := &xy[1]
		y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
		y.k = add(unsafe.Pointer(y.b), dataOffset)
		y.v = add(y.k, bucketCnt*uintptr(t.keysize))
```

[`runtime.evacuate`](https://draveness.me/golang/tree/runtime.evacuate) ä¼šå°†ä¸€ä¸ªæ—§æ¡¶ä¸­çš„æ•°æ®åˆ†æµåˆ°ä¸¤ä¸ªæ–°æ¡¶ï¼Œæ‰€ä»¥å®ƒä¼šåˆ›å»ºä¸¤ä¸ªç”¨äºä¿å­˜åˆ†é…ä¸Šä¸‹æ–‡çš„ [`runtime.evacDst`](https://draveness.me/golang/tree/runtime.evacDst) ç»“æ„ä½“ï¼Œè¿™ä¸¤ä¸ªç»“æ„ä½“åˆ†åˆ«æŒ‡å‘äº†ä¸€ä¸ªæ–°æ¡¶ï¼š

![hashmap-evacuate-destination](../../../images/go/hashmap-evacuate-destination.png)

å¦‚æœè¿™æ˜¯ç­‰é‡æ‰©å®¹ï¼Œé‚£ä¹ˆæ—§æ¡¶ä¸æ–°æ¡¶ä¹‹é—´æ˜¯ä¸€å¯¹ä¸€çš„å…³ç³»ï¼Œæ‰€ä»¥ä¸¤ä¸ª [`runtime.evacDst`](https://draveness.me/golang/tree/runtime.evacDst) åªä¼šåˆå§‹åŒ–ä¸€ä¸ªã€‚è€Œå½“å“ˆå¸Œè¡¨çš„å®¹é‡ç¿»å€æ—¶ï¼Œæ¯ä¸ªæ—§æ¡¶çš„å…ƒç´ ä¼šéƒ½åˆ†æµåˆ°æ–°åˆ›å»ºçš„ä¸¤ä¸ªæ¡¶ä¸­ï¼Œè¿™é‡Œä»”ç»†åˆ†æä¸€ä¸‹åˆ†æµå…ƒç´ çš„é€»è¾‘ï¼š

```go
		for ; b != nil; b = b.overflow(t) {
			k := add(unsafe.Pointer(b), dataOffset)
			v := add(k, bucketCnt*uintptr(t.keysize))
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
				top := b.tophash[i]
				k2 := k
				var useY uint8
				hash := t.key.alg.hash(k2, uintptr(h.hash0))
				if hash&newbit != 0 {
					useY = 1
				}
				b.tophash[i] = evacuatedX + useY
				dst := &xy[useY]

				if dst.i == bucketCnt {
					dst.b = h.newoverflow(t, dst.b)
					dst.i = 0
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
					dst.v = add(dst.k, bucketCnt*uintptr(t.keysize))
				}
				dst.b.tophash[dst.i&(bucketCnt-1)] = top
				typedmemmove(t.key, dst.k, k)
				typedmemmove(t.elem, dst.v, v)
				dst.i++
				dst.k = add(dst.k, uintptr(t.keysize))
				dst.v = add(dst.v, uintptr(t.valuesize))
			}
		}
		...
}
```

æˆ‘ä»¬ä¸€èˆ¬éƒ½ä¼šä½¿ç”¨å–æ¨¡æˆ–è€…ä½æ“ä½œæ¥è·å–æ¡¶çš„ç¼–å·ï¼Œå‡å¦‚å½“å‰å“ˆå¸Œä¸­åŒ…å« 4 ä¸ªæ¡¶ï¼Œé‚£ä¹ˆå®ƒçš„æ¡¶æ©ç å°±æ˜¯ 0b11(3)ï¼Œä½¿ç”¨ä½æ“ä½œå°±ä¼šå¾—åˆ° 3ï¼Œ æˆ‘ä»¬å°±ä¼šåœ¨ 3 å·æ¡¶ä¸­å­˜å‚¨è¯¥æ•°æ®ï¼š

```ruby
0xb72bfae3f3285244c4732ce457cca823bc189e0b & 0b11 #=> 0
```

å¦‚æœæ–°çš„å“ˆå¸Œè¡¨æœ‰ 8 ä¸ªæ¡¶ï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒåŸæ¥ç»è¿‡æ¡¶æ©ç  `0b11` ç»“æœä¸º 3 çš„æ•°æ®ä¼šå› ä¸ºæ¡¶æ©ç å¢åŠ äº†ä¸€ä½å˜æˆ `0b111` è€Œåˆ†æµåˆ°æ–°çš„ 3 å·å’Œ 7 å·æ¡¶ï¼Œæ‰€æœ‰æ•°æ®ä¹Ÿéƒ½ä¼šè¢« [`runtime.typedmemmove`](https://draveness.me/golang/tree/runtime.typedmemmove) æ‹·è´åˆ°ç›®æ ‡æ¡¶ä¸­ï¼š

![hashmap-bucket-evacuate](../../../images/go/hashmap-bucket-evacuate.png)

**å“ˆå¸Œè¡¨æ¡¶æ•°æ®çš„åˆ†æµ**

[`runtime.evacuate`](https://draveness.me/golang/tree/runtime.evacuate) æœ€åä¼šè°ƒç”¨ [`runtime.advanceEvacuationMark`](https://draveness.me/golang/tree/runtime.advanceEvacuationMark) å¢åŠ å“ˆå¸Œçš„ `nevacuate` è®¡æ•°å™¨å¹¶åœ¨æ‰€æœ‰çš„æ—§æ¡¶éƒ½è¢«åˆ†æµåæ¸…ç©ºå“ˆå¸Œçš„ `oldbuckets` å’Œ `oldoverflow`ï¼š

```go
func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {
	h.nevacuate++
	stop := h.nevacuate + 1024
	if stop > newbit {
		stop = newbit
	}
	for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
		h.nevacuate++
	}
	if h.nevacuate == newbit { // newbit == # of oldbuckets
		h.oldbuckets = nil
		if h.extra != nil {
			h.extra.oldoverflow = nil
		}
		h.flags &^= sameSizeGrow
	}
}
```

ä¹‹å‰åœ¨åˆ†æå“ˆå¸Œè¡¨è®¿é—®å‡½æ•° [`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1) æ—¶å…¶å®çœç•¥äº†æ‰©å®¹æœŸé—´è·å–é”®å€¼å¯¹çš„é€»è¾‘ï¼Œå½“å“ˆå¸Œè¡¨çš„ `oldbuckets` å­˜åœ¨æ—¶ï¼Œä¼šå…ˆå®šä½åˆ°æ—§æ¡¶å¹¶åœ¨è¯¥æ¡¶æ²¡æœ‰è¢«åˆ†æµæ—¶ä»ä¸­è·å–é”®å€¼å¯¹ã€‚

```go
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	...
	alg := t.key.alg
	hash := alg.hash(key, uintptr(h.hash0))
	m := bucketMask(h.B)
	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
	if c := h.oldbuckets; c != nil {
		if !h.sameSizeGrow() {
			m >>= 1
		}
		oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
		if !evacuated(oldb) {
			b = oldb
		}
	}
bucketloop:
	...
}
```

å› ä¸ºæ—§æ¡¶ä¸­çš„å…ƒç´ è¿˜æ²¡æœ‰è¢« [`runtime.evacuate`](https://draveness.me/golang/tree/runtime.evacuate) å‡½æ•°åˆ†æµï¼Œå…¶ä¸­è¿˜ä¿å­˜ç€æˆ‘ä»¬éœ€è¦ä½¿ç”¨çš„æ•°æ®ï¼Œæ‰€ä»¥æ—§æ¡¶ä¼šæ›¿ä»£æ–°åˆ›å»ºçš„ç©ºæ¡¶æä¾›æ•°æ®ã€‚

æˆ‘ä»¬åœ¨ [`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) å‡½æ•°ä¸­ä¹Ÿçœç•¥äº†ä¸€æ®µé€»è¾‘ï¼Œå½“å“ˆå¸Œè¡¨æ­£åœ¨å¤„äºæ‰©å®¹çŠ¶æ€æ—¶ï¼Œæ¯æ¬¡å‘å“ˆå¸Œè¡¨å†™å…¥å€¼æ—¶éƒ½ä¼šè§¦å‘ [`runtime.growWork`](https://draveness.me/golang/tree/runtime.growWork) å¢é‡æ‹·è´å“ˆå¸Œè¡¨ä¸­çš„å†…å®¹ï¼š

```go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	...
again:
	bucket := hash & bucketMask(h.B)
	if h.growing() {
		growWork(t, h, bucket)
	}
	...
}
```

å½“ç„¶é™¤äº†å†™å…¥æ“ä½œä¹‹å¤–ï¼Œåˆ é™¤æ“ä½œä¹Ÿä¼šåœ¨å“ˆå¸Œè¡¨æ‰©å®¹æœŸé—´è§¦å‘ [`runtime.growWork`](https://draveness.me/golang/tree/runtime.growWork)ï¼Œè§¦å‘çš„æ–¹å¼å’Œä»£ç ä¸è¿™é‡Œçš„é€»è¾‘å‡ ä¹å®Œå…¨ç›¸åŒï¼Œéƒ½æ˜¯è®¡ç®—å½“å‰å€¼æ‰€åœ¨çš„æ¡¶ï¼Œç„¶åæ‹·è´æ¡¶ä¸­çš„å…ƒç´ ã€‚

ç®€å•æ€»ç»“ä¸€ä¸‹å“ˆå¸Œè¡¨æ‰©å®¹çš„è®¾è®¡å’ŒåŸç†ï¼Œå“ˆå¸Œåœ¨å­˜å‚¨å…ƒç´ è¿‡å¤šæ—¶ä¼šè§¦å‘æ‰©å®¹æ“ä½œï¼Œæ¯æ¬¡éƒ½ä¼šå°†æ¡¶çš„æ•°é‡ç¿»å€ï¼Œæ‰©å®¹è¿‡ç¨‹ä¸æ˜¯åŸå­çš„ï¼Œè€Œæ˜¯é€šè¿‡ [`runtime.growWork`](https://draveness.me/golang/tree/runtime.growWork) å¢é‡è§¦å‘çš„ï¼Œåœ¨æ‰©å®¹æœŸé—´è®¿é—®å“ˆå¸Œè¡¨æ—¶ä¼šä½¿ç”¨æ—§æ¡¶ï¼Œå‘å“ˆå¸Œè¡¨å†™å…¥æ•°æ®æ—¶ä¼šè§¦å‘æ—§æ¡¶å…ƒç´ çš„åˆ†æµã€‚é™¤äº†è¿™ç§æ­£å¸¸çš„æ‰©å®¹ä¹‹å¤–ï¼Œä¸ºäº†è§£å†³å¤§é‡å†™å…¥ã€åˆ é™¤é€ æˆçš„å†…å­˜æ³„æ¼é—®é¢˜ï¼Œå“ˆå¸Œå¼•å…¥äº† `sameSizeGrow` è¿™ä¸€æœºåˆ¶ï¼Œåœ¨å‡ºç°è¾ƒå¤šæº¢å‡ºæ¡¶æ—¶ä¼šæ•´ç†å“ˆå¸Œçš„å†…å­˜å‡å°‘ç©ºé—´çš„å ç”¨ã€‚

#### åˆ é™¤

å¦‚æœæƒ³è¦åˆ é™¤å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œå°±éœ€è¦ä½¿ç”¨ Go è¯­è¨€ä¸­çš„ `delete` å…³é”®å­—ï¼Œè¿™ä¸ªå…³é”®å­—çš„å”¯ä¸€ä½œç”¨å°±æ˜¯å°†æŸä¸€ä¸ªé”®å¯¹åº”çš„å…ƒç´ ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ï¼Œæ— è®ºæ˜¯è¯¥é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨ï¼Œè¿™ä¸ªå†…å»ºçš„å‡½æ•°éƒ½ä¸ä¼šè¿”å›ä»»ä½•çš„ç»“æœã€‚

![hashmap-delete](https://img.draveness.me/2020-10-18-16030322432592/hashmap-delete.png)

**å“ˆå¸Œè¡¨åˆ é™¤æ“ä½œ**

åœ¨ç¼–è¯‘æœŸé—´ï¼Œ`delete` å…³é”®å­—ä¼šè¢«è½¬æ¢æˆæ“ä½œä¸º `ODELETE` çš„èŠ‚ç‚¹ï¼Œè€Œ [`cmd/compile/internal/gc.walkexpr`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr) ä¼šå°† `ODELETE` èŠ‚ç‚¹è½¬æ¢æˆ [`runtime.mapdelete`](https://draveness.me/golang/tree/runtime.mapdelete) å‡½æ•°ç°‡ä¸­çš„ä¸€ä¸ªï¼ŒåŒ…æ‹¬ [`runtime.mapdelete`](https://draveness.me/golang/tree/runtime.mapdelete)ã€`mapdelete_faststr`ã€`mapdelete_fast32` å’Œ `mapdelete_fast64`ï¼š

```go
func walkexpr(n *Node, init *Nodes) *Node {
	switch n.Op {
	case ODELETE:
		init.AppendNodes(&n.Ninit)
		map_ := n.List.First()
		key := n.List.Second()
		map_ = walkexpr(map_, init)
		key = walkexpr(key, init)

		t := map_.Type
		fast := mapfast(t)
		if fast == mapslow {
			key = nod(OADDR, key, nil)
		}
		n = mkcall1(mapfndel(mapdelete[fast], t), nil, init, typename(t), map_, key)
	}
}
```

è¿™äº›å‡½æ•°çš„å®ç°å…¶å®å·®ä¸å¤šï¼ŒæŒ‘é€‰å…¶ä¸­çš„ [`runtime.mapdelete`](https://draveness.me/golang/tree/runtime.mapdelete) åˆ†æä¸€ä¸‹ã€‚å“ˆå¸Œè¡¨çš„åˆ é™¤é€»è¾‘ä¸å†™å…¥é€»è¾‘å¾ˆç›¸ä¼¼ï¼Œåªæ˜¯è§¦å‘å“ˆå¸Œçš„åˆ é™¤éœ€è¦ä½¿ç”¨å…³é”®å­—ï¼Œå¦‚æœåœ¨åˆ é™¤æœŸé—´é‡åˆ°äº†å“ˆå¸Œè¡¨çš„æ‰©å®¹ï¼Œå°±ä¼šåˆ†æµæ¡¶ä¸­çš„å…ƒç´ ï¼Œåˆ†æµç»“æŸä¹‹åä¼šæ‰¾åˆ°æ¡¶ä¸­çš„ç›®æ ‡å…ƒç´ å®Œæˆé”®å€¼å¯¹çš„åˆ é™¤å·¥ä½œã€‚

```go
func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {
	...
	if h.growing() {
		growWork(t, h, bucket)
	}
	...
search:
	for ; b != nil; b = b.overflow(t) {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if b.tophash[i] == emptyRest {
					break search
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			k2 := k
			if !alg.equal(key, k2) {
				continue
			}
			*(*unsafe.Pointer)(k) = nil
			v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
			*(*unsafe.Pointer)(v) = nil
			b.tophash[i] = emptyOne
			...
		}
	}
}
```

å…¶å®åªéœ€è¦çŸ¥é“ `delete` å…³é”®å­—åœ¨ç¼–è¯‘æœŸé—´ç»è¿‡[ç±»å‹æ£€æŸ¥](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/)å’Œ[ä¸­é—´ä»£ç ç”Ÿæˆ](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/)é˜¶æ®µè¢«è½¬æ¢æˆ [`runtime.mapdelete`](https://draveness.me/golang/tree/runtime.mapdelete) å‡½æ•°ç°‡ä¸­çš„ä¸€å‘˜ï¼Œç”¨äºå¤„ç†åˆ é™¤é€»è¾‘çš„å‡½æ•°ä¸å“ˆå¸Œè¡¨çš„ [`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) å‡ ä¹å®Œå…¨ç›¸åŒï¼Œä¸å¤ªéœ€è¦åˆ»æ„å…³æ³¨ã€‚

### å°ç»“

Go è¯­è¨€ä½¿ç”¨æ‹‰é“¾æ³•æ¥è§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜å®ç°äº†å“ˆå¸Œè¡¨ï¼Œå®ƒçš„è®¿é—®ã€å†™å…¥å’Œåˆ é™¤ç­‰æ“ä½œéƒ½åœ¨ç¼–è¯‘æœŸé—´è½¬æ¢æˆäº†è¿è¡Œæ—¶çš„å‡½æ•°æˆ–è€…æ–¹æ³•ã€‚å“ˆå¸Œåœ¨æ¯ä¸€ä¸ªæ¡¶ä¸­å­˜å‚¨é”®å¯¹åº”å“ˆå¸Œçš„å‰ 8 ä½ï¼Œå½“å¯¹å“ˆå¸Œè¿›è¡Œæ“ä½œæ—¶ï¼Œè¿™äº› `tophash` å°±æˆä¸ºå¯ä»¥å¸®åŠ©å“ˆå¸Œå¿«é€Ÿéå†æ¡¶ä¸­å…ƒç´ çš„ç¼“å­˜ã€‚

å“ˆå¸Œè¡¨çš„æ¯ä¸ªæ¡¶éƒ½åªèƒ½å­˜å‚¨ 8 ä¸ªé”®å€¼å¯¹ï¼Œä¸€æ—¦å½“å‰å“ˆå¸Œçš„æŸä¸ªæ¡¶è¶…å‡º 8 ä¸ªï¼Œæ–°çš„é”®å€¼å¯¹å°±ä¼šå­˜å‚¨åˆ°å“ˆå¸Œçš„æº¢å‡ºæ¡¶ä¸­ã€‚éšç€é”®å€¼å¯¹æ•°é‡çš„å¢åŠ ï¼Œæº¢å‡ºæ¡¶çš„æ•°é‡å’Œå“ˆå¸Œçš„è£…è½½å› å­ä¹Ÿä¼šé€æ¸å‡é«˜ï¼Œè¶…è¿‡ä¸€å®šèŒƒå›´å°±ä¼šè§¦å‘æ‰©å®¹ï¼Œæ‰©å®¹ä¼šå°†æ¡¶çš„æ•°é‡ç¿»å€ï¼Œå…ƒç´ å†åˆ†é…çš„è¿‡ç¨‹ä¹Ÿæ˜¯åœ¨è°ƒç”¨å†™æ“ä½œæ—¶å¢é‡è¿›è¡Œçš„ï¼Œä¸ä¼šé€ æˆæ€§èƒ½çš„ç¬æ—¶å·¨å¤§æŠ–åŠ¨ã€‚