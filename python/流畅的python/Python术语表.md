## Python术语表

  - **CPython**：标准的Python解释器，使用C语言实现。
  - **CRUD**：Create、Read、Update、Delete的首字母缩写，这是存储记录的应用程序中的四种基本操作。
  - **DRY**：Don't Repeat Yourself（不要自我重复）的缩写，一种软件工程原则，意思是：“系统中的每一项知识都必须具有单一、无歧义、权威的表示。”首先由Andy Hunt与Dave Thomas的《程序员修炼之道：从小工到专家》一书提出。
  - **dunder**：首尾有两条下划线的特殊方法和属性的简洁读法（即把`__len__`读成“dunder len”）。
  - **EAFP**: “it's easier to ask forgiveness thanpermission”（取得原谅比获得许可容易）的首字母缩写。人们认为这句话是计算机先驱GraceHopper说的，Python程序员使用这个缩写指代一种动态编程方式，例如访问属性前不测试有没有属性，如果没有就捕获异常。 hasattr函数的文档字符串是这样描述它的工作方式的：“调用getattr(object, name)，然后捕获AttributeError异常。”
  - **KISS原则**: KISS是“Keep It Simple, Stupid”的首字母缩写。这个原则要求尽量寻找最简单的方案，尽量减少可变部分。
  - **ORM**: Object-Relational Mapper（对象关系映射器）的缩写，通过这种API可以使用Python类和对象访问数据库中的表和记录，而且调用方法可以执行数据库操作。SQLAlchemy是流行的独立PythonORM，Django和Web2py自带了ORM。
  - **PyPI**: Python包索引，里面有超过60000个包可用。也叫**奶酪店**（参见奶酪店词条）。为了防止与PyPy混淆，PyPI应该读作“pie-P-eye”。
  - **PyPy**: Python编程语言的另一种实现，使用一个工具链把部分Python编译成机器码，因此解释器的源码其实是使用Python编写的。PyPy还提供了JIT，即时把用户的程序编译成机器码——与Java VM的作用相同。根据PyPy公布的基准测试，从2014年11月起，PyPy平均比CPython快6.8倍。为了防止与PyPI混淆， PyPy应该读作“pie-pie”。
  - **绑定方法（bound method）** : 通过实例访问的方法会绑定到那个实例上。方法其实是描述符，访问方法时，会返回一个包装自身的对象，把方法绑定到实例上。那个对象就是绑定方法。调用绑定方法时，可以不传入self的值。例如，像my_method=my_obj.method这样赋值之后，可以通过my_method（　）调用绑定方法。请与非绑定方法相比较。
  - **抽象基类（abstract base class，ABC）** : 无法实例化，只能扩展的类。Python通过ABC实现接口。除了继承ABC之外，类还可以注册成为ABC的虚拟子类，声明自己实现了接口。
  - **迭代器（iterator）** : 实现了无参数方法`__next__`的对象；这个方法返回级数里的下一个元素，如果没有元素了就抛出StopIteration异常。在Python中，迭代器还实现了`__iter__`方法，因此迭代器也是可迭代的对象。根据最初的设计模式，经典迭代器返回集合里的元素。生成器也是迭代器，不过更灵活。
  - **泛函数（generic function）** : 以不同的方式为不同类型的对象实现相同操作的一组函数。从Python 3.4起，创建泛函数的标准方式是使用functools.singledispatch装饰器。在其他语言中，这叫多分派方法。
  - **非绑定方法（unbound method）** : 直接通过类访问的实例方法没有绑定到特定的实例上，因此把这种方法称为“非绑定方法”。若想成功调用非绑定方法，必须显式传入类的实例作为第一个参数。那个实例会赋值给方法的self参数。
  - **非覆盖型描述符（nonoverriding descriptor）** : 未实现`__set__`方法的描述符，不干涉托管实例中托管属性的设置。因此，托管实例中的同名属性会遮盖实例中的描述符。也叫非数据描述符或遮盖型描述符。请与覆盖型描述符相比较。
  - **覆盖型描述符（overriding descriptor）** :实现了`__set__`方法的描述符，设置托管实例中的托管属性时会遭到拦截并覆盖相关操作。也叫数据描述符或强制描述符。请与非覆盖型描述符相比较。
  - **惯用句法（idiom）** : 根据普林斯顿大学WordNet字典的定义，惯用句法指“说母语的人说话的方式”。
  - **猴子补丁（monkey patching）** : 在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在内存中发挥作用，不会修改源码，因此只对当前运行的程序实例有效。因为猴子补丁破坏了封装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不是集成代码的推荐方式。
  - **混入方法（mixin method）** : 抽象基类或混入类中方法的具体实现。
  - **混入类（mixin class）** : 用于随着多重继承类树中的一个或多个类一起扩展的类。混入类绝不能实例化，它的具体子类也应该是其他非混入类的子类。
  - **及早求值（eager）** : 指可迭代对象一次构建好全部元素。在Python中，列表推导会及早求值。请与惰性求值相比较。
  - **集合（collection）** : 泛指由元素组成，可以单独访问各个元素的数据结构。有些集合可以包含任意类型的对象（参见容器词条），有些则只能包含一种原子类型的对象（参见平坦序列词条）。list和bytes都是集合，只不过list是容器，而bytes是平坦序列。
  - **尽早失败（fail-fast）** : 一种系统设计方式，建议应该尽早报告错误。Python比其他大多数动态编程语言更遵守这一原则。例如，Python中没有“未定义”的值：在初始化之前引用变量会报错；如果k不存在，my_dict[k]会抛出异常（JavaScript则不然）。还有一例：在Python中通过元组拆包做并行赋值，必须显式处理元组的每一个元素才行；而在Ruby中，如果=两边的元素数量不一致，右边未用到的元素会被忽略，或者把nil赋给左边多余的变量。
  - **可迭代的（iterable）** : 使用内置的iter函数可以从中获得迭代器的对象。可迭代的对象为for循环、列表推导和元组拆包提供元素。如果对象的`__iter__`方法能返回迭代器，这就是可迭代的对象。序列都是可迭代的对象；此外，实现`__getitem__`方法的对象也是可迭代的对象。
  - **可迭代对象的拆包（iterable unpacking）** : 元组拆包更现代、更精确的同义词。另见并行赋值词条。
  - **可散列的（hashable）** : 在散列值永不改变，而且如果`a==b`，那么`hash(a)==hash(b)`也是True的情况下，如果对象既有`__hash__`方法，也有`__eq__`方法，那么这样的对象称为可散列的对象。在内置的类型中，大多数不可变的类型都是可散列的；但是，仅当元组的每一个元素都是可散列的时，元组才是可散列的。
  - **列表推导（list comprehension）** : 放在方括号里的表达式，使用关键字for和in，通过处理和过滤一个或多个可迭代对象里的元素构建列表。列表推导会及早求值。参见及早求值词条。
  - **描述符（descriptor）** : 一个类，实现`__get__`、`__set__`和`__delete__`特殊方法中的一个或多个，其实例作为另一个类（托管类）的类属性。描述符管理托管类中托管属性的存取和删除，数据通常存储在托管实例中。
  - **名称改写（name mangling）** : Python解释器在运行时自动把私有属性`__x`重命名为`_MyClass__x`。
  - **浅复制（shallow copy）** 一种对象副本，引用源对象的全部属性对象。请与深复制相比较。另见别名词条。
  - **强引用（strong reference）** 让对象始终存在于Python中的引用。请与弱引用相比较。
  - **弱引用（weak reference）** 一种特殊的对象引用方式，不计入指示对象的引用计数。弱引用使用weakref模块里的某个函数和数据结构创建。
  - **上下文管理器（context manager）** 实现了`__enter__`和`__exit__`特殊方法的对象，在with块中使用。
  - **深复制（deep copy）** 复制对象时把对象的所有属性一起复制。请与浅复制相比较。
  - **生成器（generator）** 使用生成器函数或生成器表达式构建的迭代器，无需迭代集合就可能生成值。生成斐波纳契数列的生成器是个典型示例，这是一种无穷数列，在集合中绝对放不下。这个术语除了表示调用生成器函数得到的对象之外，有时还表示生成器函数。
  - **生成器表达式（generator expression）** 放在括号里的表达式，句法与列表推导一样，不过返回的不是列表，而是生成器。生成器表达式可以理解为列表推导的惰性版本。参见惰性求值词条。
  - **属性（attribute）** 在Python中，方法和数据属性（即Java术语中的“字段”）都是属性。方法也是属性，只不过恰好是可调用的对象（通常是函数，但也不一定）
  - **托管类（managed class）** 使用描述符对象管理类中某个属性的类。参见描述符词条。
  - **托管实例（managed instance）** 托管类的实例。参见托管属性和描述符词条。
  - **托管属性（managed attribute）** 由描述符对象管理的公开属性。虽然托管属性在托管类中定义，但是作用相当于实例属性（即各个实例通常有各自的值，存储在储存属性中）。参见描述符词条。
  - **协程（coroutine）** 用于并发编程的生成器，从调度程序，或者通过coro.send(value)方法从事件循环中接收值。这个术语可以表示通过调用生成器函数获得的生成器函数或生成器对象。参见生成器词条。
  - **虚拟子类（virtual subclass）** 不继承自超类，而是使用TheSuperClass.register(TheSubClass)注册的类。参见abc.ABCMeta.register方法的文档。
  - **序列化（serialization）** 把对象在内存中的结构转换成便于存储或传输的二进制或文本格式，而且以后可以在同一个系统或不同的系统中重建对象的副本。pickle模块能把任何Python对象序列化成二进制格式。
  - **鸭子类型（duck typing）** 多态的一种形式，在这种形式中，不管对象属于哪个类，也不管声明的具体接口是什么，只要对象实现了相应的方法，函数就可以在对象上执行操作。
  - **一等函数（first-class function）** 在语言中属于一等对象的函数（即能在运行时创建，赋值给变量，当作参数传入，以及作为另一个函数的返回值）。Python中的函数都是一等函数。
  - **元类（metaclass）** 实例为类的类。默认情况下，Python中的类是type类的实例；例如，type(int)得到的结果是type类，因此type是元类。用户可以通过扩展type类定义元类。
  - **元组拆包（tuple unpacking）** 把可迭代对象中的元素赋值给多个变量（例如，first, second, third==my_list）。Python高手通常使用这个术语，不过也有人使用可迭代对象的拆包。
  - **装饰器（decorator）** 一个可调用的对象A，返回另一个可调用的对象B，在可调用的对象C的定义体之前使用句法@A调用。Python解释器读取这样的代码时，会调用A(C)，把返回的B绑定给之前赋予C的变量，也就是把C的定义体换成B。如果目标可调用对象C是函数，那么A是函数装饰器；如果C是类，那么A是类装饰器。