# 理解Linux线程（2）

## 线程与信号

信号出现地要比线程早，所以设计信号时，尚没有线程。在引入线程之后，如何设计信号成了一个难点。

- 信号处理函数是进程层面的概念，或者说是线程组层面的概念，线程组内所有线程共享对信号的处理函数。
- 对于发送给进程的信号，内核会任选一个线程来执行信号处理函数，执行完后，会将其从挂起信号队列中去除，其他进程不会对一个信号重复响应。
- 可以针对进程中的某个线程发送信号，那么只有该线程能响应，执行相应的信号处理函数。
- 信号掩码是线程层面的概念，信号处理函数在线程组内是统一的，但是信号掩码是各自独立可配置的，各个线程独立配置自己要阻止或放行的信号集合。
- 挂起信号（内核已经收到，但尚未递送给线程处理的信号）既是针对进程的，又是针对线程的。内核维护两个挂起信号队列，一个是进程共享的挂起信号队列，一个是线程特有的挂起信号队列。调用函数sigpending返回的是两者的并集。对于线程而言，优先递送发给线程自身的信号。

### 设置线程的信号掩码

前面已提到过，信号掩码是针对线程的，每个线程都可以自行设置自己的信号掩码。如果自己不设置，就会继承创建者的信号掩码。

NPTL实现了如下接口来设置线程的信号掩码：

```c
#include <signal.h>
int pthread_sigmask(int how, const sigset_t *new, sigset_t *old);
```

how的值用来指定如何更改信号组：

- SIG_BLOCK向当前信号掩码中添加new，其中new表示要阻塞的信号组。
- SIG_UNBLOCK从当前信号掩码中删除new，其中new表示要取消阻塞的信号组。
- SIG_SETMASK将当前信号掩码替换为new，其中new表示新的信号掩码。

>  SIGCANCEL和SIGSETXID信号被用于NPTL实现，因此用户不能也不应该改变这两个信号的行为方式。好在用户不用操心这两个信号，sigprocmask函数和pthread_sigmask函数对这两者都做了特殊处理。

### 向线程发送信号

线程发送信号的系统调用tkill/tgkill，无奈glibc并未将它们封装成可以直接调用的函数。不过，幸好提供了另外一个函数：

```c
int pthread_kill(pthread_t thread, int sig);
```

由于pthread_t类型的线程ID只在线程组内是唯一的，其他进程完全可能存在线程ID相同的线程，所以pthread_kill只能向同一个进程的线程发送信号。

除了这个接口外，Linux还提供了特有的函数将pthread_kill和sigqueue功能累加在一起：

```c
#define _GNU_SOURCE
#include <pthread.h>
int pthread_sigqueue(pthread_t thread, int sig,
               const union sigval value);
```

这个接口和sigqueue一样，可以发送携带数据的信号。当然，只能发给同一个进程内的线程。

### 多线程程序对信号的处理

单线程的程序，对信号的处理已经比较复杂了。因为信号打断了进程的控制流，所以信号处理函数只能调用异步信号安全的函数。而异步信号安全是个很苛刻的条件。

多线程的引入，加剧了这种复杂度。因为信号可以发送给进程，也可以发送给进程内的某一线程。不同线程还可以设置自己的掩码来实现对信号的屏蔽。而且，没有一个线程相关的函数是异步信号安全的，信号处理函数不能调用任何pthread函数，也不能通过条件变量来通知其他线程。

正如陈硕在《Linux多线程服务器编程》中提到的，在多线程程序中，使用信号的第一原则就是不要使用信号。

## 多线程与fork（）

多线程和fork函数的协作性非常差。对于多线程和fork，最重要的建议就是永远不要在多线程程序里面调用fork。

Linux的fork函数，会复制一个进程，对于多线程程序而言，fork函数复制的是调用fork的那个线程，而并不复制其他的线程。fork之后其他线程都不见了。Linux不存在forkall语义的系统调用，无法做到将多线程全部复制。

多线程程序在fork之前，其他线程可能正持有互斥量处理临界区的代码。fork之后，其他线程都不见了，那么互斥量的值可能处于不可用的状态，也不会有其他线程来将互斥量解锁。

现在的库函数，为了做到可重入，其内部维护的变量通常会使用互斥量来保护。这些锁对用户一般是透明的，用户也不关心。setenv和unsetenv就是这样。尽管上述代码并没有显式地定义，但是进程内部已经维护了一个互斥量。

不仅仅是setenv/unsetenv函数，库函数中类似这种的函数并不少见：

- malloc函数的内部实现一定会有锁。
- printf系列的函数，其他线程可能持有stdout/stderr的锁。
- syslog函数内部实现也会用到锁。

综合上面的讨论，唯一安全的做法是，fork之后子进程立即调用exec执行另外的程序，彻底断绝子进程与父进程之间的关系，注意是立即，不要在调用exec之前执行任何语句，哪怕是不起眼的printf。
