## 调度策略

**进程分类方法**

传统上把进程分类为**"I/O受限(I/O-bound)**"或"**CPU受限(CPU-bound)**"。前者频繁的使用I/O设备，并花费很多时间等待I/O操作完成；后者则需要大量的CPU时间的数值计算应用程序。

另一种分类方法把进程区分为三类：
- **交互式进程(interactive process)**: 这些进程经常与用户进行交互，因此，需要花费很多时间等待键盘和鼠标操作。当接受了输入后，进程必须很快被唤醒，否则用户将发现系统反应迟钝。典型的交互式程序是命令shell、文本编辑器及图形应用程序。
- **批处理程序(batch process)**: 这些进程不必与用户交互，因此经常在后台运行。这样的进程不必很快地响应，因此常受到调度程序地影响。典型地批处理进程是程序设计语言地编译程序、数据库搜索引擎及科学计算。
- **实时进程(real-time process)**: 这些进程有很强地调度需要。这样的进程决不会被低优先级的进程阻塞，它们应该有一个短的响应时间，更重要的是，响应时间的变化应该很小。典型的实时程序有视频和音频应用程序、机器人控制程序及从物理传感器上收集数据的程序。

### 进程的抢占

Linux的进程是抢占式的。如果进程进入TASK_RUNNING状态，内核检查它的动态优先级是否大于当前正在运行的进程的优先级。如果是，current的执行被中断，并调用调度程序选择另一个进程运行（通常是刚变为可运行的进程）。

当然，进程在它的时间片到期时也可以被抢占。此时，当前进程thread_info结构中的TIF_NEED_RESCHED标志被设置，以便时钟中断处理程序终止时调度程序被调用。

注：被强占的进程没有被挂起，因为它还处于TASK_RUNNING状态，只不过不再使用CPU。

### 一个时间片必须持续多长？

如果平均时间片太短，有进程切换引起的系统额外开销就会变得非常高。

如果平均时间片太长，进程看起来就不再是并发执行。

对时间片大小的选择始终是一种折衷。Linux采取单凭经验的方法，即选择尽可能长、同时能保持良好响应时间的时间片。

### 调度算法

调度程序总能成功地找到要执行地进程。总是至少有一个可运行进程，即swapper进程，它地PID等于0，而且它只有再CPU不能执行其他进程时才执行。

每个Linux进程总是按照下面地调度类型被调度：

- **SCHED_FIFO**
  - 先进先出地实时进程。当调度程序把CPU分配给进程地时候，它把改进程描述符保留在运行队列链表地当前位置。如果没有其他可运行的更高优先级实时进程，进程就继续使用CPU，想用多久就用多久，既使还有其他具有相同优先级的实时进程处于可运行状态。
- **SCHED_RR**
  - 时间片轮转的实时进程。当调度程序把CPU分配给进程的时候，它把该进程的描述符放在运行队列链表的末尾。这种策略保证对所有具有相同优先级的SCHED_RR实时进程公平的分配CPU时间。
- **SCHED_NORMAL**
  - 普通的分时进程

调度算法根据进程是普通进程还是实时进程有很大不同。

### 普通进程的调度



### 实时进程的调度

