## 操作系统基本概念

操作系统完成的两个主要目标：
- 与硬件部分交互，为包含在硬件平台上的所有底层可编程部分提供服务
- 为运行在计算机系统上的应用程序（即所谓应用程序）提供执行环境

现代操作系统依靠特殊的硬件特性禁止用户程序直接与底层硬件部分进行交互，或者禁止直接访问任意的物理地址。硬件为CPU引入了至少两种不同的执行模式：用户程序的非特权模式和内核的特权模式。Unix把它们分别称为**用户态(User Mode)**和**内核态(Kernel Mode)**。

### 多用户系统

多用户系统(multiuser system)就是一台能并发和独立地执行分别属于两个或多个用户的若干应用程序的计算机。
- ”并发“(concurrently)以为着几个应用程序能同时处于活动状态并竞争各种资源，如CPU、内存、硬盘等等。
- “独立”(independently)意味着每个应用程序能执行自己的任务，而无需考虑其他用户的应用程序在干些什么。

多用户操作系统必须包含以下几个特点：

- 核实用户身份认证的机制
- 防止有错误的用户程序妨碍其他应用程序在系统中运行的保护机制
- 防止有恶意的用户程序干涉或窥视其他用户的活动的保护机制
- 限制分配给每个用户的资源数的记账机制

### 用户和组

在多用户系统中，每个用户在机器上都有私有空间。

所有的用户由一个唯一的数字来标识，这个数字叫用户标识符（UserID，UID）

为了和其他用户有选择的共享资料，每个用户是一个或多个用户组的一名成员，组由唯一的用户组标识符（user group ID）标识。每个文件也恰好与一个组相对应。

## Unix 文件系统概述

### 文件类型

Unix文件可以是下列类型之一：

- 普通文件（regular file）
- 目录
- 符号链接
- 面向块的设备文件（block-oriented device file）
- 面向字符的设备文件（character-oriented device file）
- 管道（pipe）和命名管道（named piped）（也叫FIFO）
- 套接字（socket）

### 文件描述符与索引节点

Unix对文件的内容和描述文件的信息给出了清除的区分。除了设备文件和特殊文件系统文件外，每个文件都由字符序列组成。文件内容不包含任何控制信息。

文件系统处理文件所需要的信息包含在一个名为索引节点（inode）的数据结构中。每个文件都有自己的索引节点，文件系统用索引节点来标识文件。

文件系统至少提供在POSIX标准中指定的如下属性：

- 文件类型
- 与文件相关的硬链接的个数
- 以字节为单位的文件长度
- 设备标识符（即包含文件的设备标识符）
- 在文件系统中标识文件的索引节点号
- 文件拥有者的UID
- 文件的用户组ID
- 几个时间戳，表示索引节点状态改变的时间、最后访问时间及最后修改时间
- 访问权限和文件模式



## Unix内核概述

### 进程/内核模式

当一个程序在用户态下执行时，它不能直接访问内核数据结构或者内核的程序。然而，当应用程序在内核态下运行时，这些限制不再有效。

内核本身不是一个进程，而是进程的管理者。

进程/内核模式假定：请求内核服务的进程使用所谓系统调用(system call)的特殊编程机制。每个系统调用都设置了一组识别进程请求的参数，然后执行与硬件相关的CPU指令完成从用户到内核态的转换。

激活内核例程的几种方式：

- 进程调用系统调用
- 正在执行进程的CPU发出一个异常(exception)信号，内核代表产生异常的进程处理异常。
- 外围设备向CPU发出一个中断(interrupt)信号以通知一个事件的发声，例如一个要求注意的请求、一个状态的变化或一个I/O操作已经完成等。每个中断信号都是由内核中的**中断处理程序(interrupt handler)**来处理的。因为外围设备与CPU是异步操作，因此，中断在不可预知的时间发生。
- 内核线程被执行。

### 进程实现

每个进程由一个**进程描述符(process descriptor)**表示，这个描述符包含有关进程当前状态的信息。

当内核暂停一个进程的执行时，就把几个相关处理器寄存器的内容保存在进程描述符中。这些寄存器包括：

- 程序计数器(PC)和栈指针(SP)寄存器
- 通用寄存器
- 浮点寄存器
- 包含CPU状态信息的处理器控制寄存器(处理器状态字，Processor Status Word)
- 用来跟踪进程对RAM访问的内存管理寄存器

当内核恢复执行一个进程时，它用进程描述符中适合的字段来装载CPU寄存器。因为程序计数器中所存的值指向下一条将要执行的指令，所以进程从它停止的地方恢复执行。

Unix内核可以区分很多等待状态，这些等待状态通常由进程描述符队列实现。

### 进程地址空间

每个进程运行在它的私有地址空间。在用户态下运行的进程涉及到私有栈、数据区和代码区。当在内核态运行时，进程访问内核的数据区和代码区，但使用另外的私有栈。

尽管看起来每个进程访问一个私有地址空间，但有时进程之间也共享这部分地址空间。在一些情况下，这种共享由进程显式提出；在另一些情况下，由内核自动完成共享以节约内存。进程间能共享部分地址空间，以实现一种进程间通信，这就是由System V引入并已经被Linux支持地"共享内存"技术。

Linux支持mmap()系统调用，该系统调用允许存放在块设备上的文件或者信息的一部分映射到进程的部分地址空间。内存映射为正常的读写传送数据提供了另一种选择。如果同一个文件由几个进程共享，那么共享它的每个进程地址空间都包含它的内存映射。

