## 1 设计模式介绍

**设计原则：**

- **识别应用中变化的方面，把它们和不变的方面分开**
  - 把会变化的部分取出并封装，这样，以后你就可以修改或扩展这个部分，而不会影响其他不需要变化的部分。


- **针对接口编程，而不是针对实现编程。**
  - “针对接口编程”真正的意思是“针对超类型编程”。

- **优先使用组合而不是继承**

**策略模式**：策略模式定义了一个算法族，分别封装起来，使得它们之间可以互相变换。策略让算法的变化独立于使用它的客户。

## 2 观察者模式

**观察者模式**：定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

**设计原则：**尽量做到交互的对象之间的松耦合设计。

## 3 装饰者模式

**开放-关闭原则**：类应该对扩展开放，但对修改关闭。

**装饰者模式**：动态地将额外责任附加到对象上。用于扩展功能，装饰者提供子类变化之外的弹性替代方案。

## 4 工厂模式

**工厂模式**：定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法让类把实例化推迟到子类。

**依赖倒置原则**(Dependency Inversion Principle)：依赖抽象，不依赖具体类。

**抽象工厂模式**：提供一个接口来创建相关或依赖对象的家族，而不需要制定具体类。

## 5 单件模式

**单件模式**：确保一个类只有一个实例，并提供一个全局访问点。

go语言的一个单件模式的示例：

```go
package singleton

import (
	"sync"
)

// Singleton 类型定义
type Singleton struct {
	// ... 其他字段
}

var instance *Singleton
var once sync.Once

// GetInstance 用于获取单一实例
func GetInstance() *Singleton {
	once.Do(func() {
		instance = &Singleton{}
	})
	return instance
}
```

## 6 命令模式

**命令模式**：把请求封装为对象，以便用不同的请求、队列或者日志请求来参数化其他对象，并支持可撤销的操作。

## 7 适配器和外观模式

**适配器模式**：将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作。

**外观模式**：为子系统中的一组接口提供了一个统一的接口。外观定义了一个更高级别的接口，使得子系统更容易使用。

**最少知识原则**：只和你的密友谈话。

- 当你在设计一个系统时，对于任何对象，都要注意它所交互的类的数量，以及它和这些类的交互。
- 这个原则防止我们创建有大量的类在一起的设计，免得系统一部分的变化会连锁影响到其他部分。当你在许多类之间造成许多依赖时，你的系统就是一个易碎的系统，需要花费许多成本维护，而且复杂得难以让别人理解。

## 8 模版方法模式

**模版方法模式**：在一个方法中定义一个算法的骨架，而把一些步骤延迟到子类。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

**好莱坞原则**：不要打电话给（调用）我们，我们会打电话给（调用）你。
